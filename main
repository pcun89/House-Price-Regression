# main_regression_embedded.py

"""
main_regression_embedded.py

Regression training pipeline (Ridge) for California Housing (sklearn).
Exports both a Python-friendly pipeline and an embedded-friendly JSON containing:
- scaler mean and scale (StandardScaler)
- model coefficients and intercept

Style:
- camelCase for variables and functions
- docstrings for each function
- main() entrypoint
- comments explaining each step
"""
from __future__ import annotations
import json
import os
from typing import Tuple, Dict, Any, List

import numpy as np
import pandas as pd
from sklearn.datasets import fetch_california_housing
from sklearn.linear_model import Ridge
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_squared_error, r2_score
import joblib

# Config
RANDOM_STATE = 42
TEST_SIZE = 0.2
OUTPUT_PIPELINE = "reg_pipeline.joblib"
OUTPUT_EMBEDDED_JSON = "embedded_model.json"


def loadDataset() -> Tuple[pd.DataFrame, pd.Series]:
    """
    Load the California Housing dataset and return (X_df, y_series).
    """
    raw = fetch_california_housing(as_frame=True)
    X_df = raw.frame.drop(
        columns=["MedHouseVal"]) if "MedHouseVal" in raw.frame.columns else raw.data
    y_series = raw.target if hasattr(
        raw, "target") else raw.frame["MedHouseVal"]
    return X_df, y_series


def splitData(X_df: pd.DataFrame, y_series: pd.Series, testSize: float = TEST_SIZE, randomState: int = RANDOM_STATE
              ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, List[str]]:
    """
    Split dataset into train/test arrays and return feature names.
    """
    featureNames = list(X_df.columns)
    X_train, X_test, y_train, y_test = train_test_split(
        X_df.values, y_series.values, test_size=testSize, random_state=randomState
    )
    return X_train, X_test, y_train, y_test, featureNames


def buildAndTrainModel(X_train: np.ndarray, y_train: np.ndarray, alpha: float = 1.0
                       ) -> Tuple[Pipeline, Ridge, StandardScaler]:
    """
    Build a Pipeline with StandardScaler + Ridge regression, fit it, and return the pipeline and components.
    """
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)

    model = Ridge(alpha=alpha, random_state=RANDOM_STATE)
    model.fit(X_train_scaled, y_train)

    # For convenience save a pipeline for Python inference
    pipeline = Pipeline([("scaler", scaler), ("regressor", model)])
    return pipeline, model, scaler


def evaluateModel(model: Ridge, scaler: StandardScaler, X_test: np.ndarray, y_test: np.ndarray) -> Dict[str, float]:
    """
    Evaluate model on test set and return metrics (RMSE, R2).
    """
    X_test_scaled = scaler.transform(X_test)
    preds = model.predict(X_test_scaled)
    rmse = mean_squared_error(y_test, preds, squared=False)
    r2 = r2_score(y_test, preds)
    print(f"Test RMSE: {rmse:.4f}")
    print(f"Test R^2: {r2:.4f}")
    return {"rmse": float(rmse), "r2": float(r2)}


def exportForEmbedded(scaler: StandardScaler, model: Ridge, featureNames: List[str], outPath: str = OUTPUT_EMBEDDED_JSON) -> None:
    """
    Export scaler params and model coefficients to a JSON file for embedding.
    JSON includes:
      - feature_names: list[str]
      - means: list[float]
      - scales: list[float]
      - coefficients: list[float]
      - intercept: float
    """
    payload = {
        "feature_names": featureNames,
        "means": scaler.mean_.astype(float).tolist(),
        "scales": scaler.scale_.astype(float).tolist(),
        "coefficients": model.coef_.astype(float).tolist(),
        "intercept": float(model.intercept_),
        "notes": "All floats are python floats; copy into embedded C arrays as float (single-precision)."
    }
    with open(outPath, "w") as fh:
        json.dump(payload, fh, indent=2)
    print(f"Wrote embedded model JSON to: {outPath}")


def savePipeline(pipeline: Pipeline, outPath: str = OUTPUT_PIPELINE) -> None:
    """
    Save the scikit-learn pipeline (scaler + model) using joblib.
    """
    joblib.dump(pipeline, outPath)
    print(f"Saved Python pipeline to: {outPath}")


def main() -> None:
    """
    End-to-end training, evaluation, and export.
    """
    print("Loading dataset...")
    X_df, y_series = loadDataset()
    X_train, X_test, y_train, y_test, featureNames = splitData(X_df, y_series)

    print("Training Ridge regression (embedded-friendly linear model)...")
    pipeline, model, scaler = buildAndTrainModel(X_train, y_train, alpha=1.0)

    print("Evaluating on test set...")
    metrics = evaluateModel(model, scaler, X_test, y_test)

    # Save pipeline for Python usage
    savePipeline(pipeline, OUTPUT_PIPELINE)

    # Export JSON for embedding in C
    exportForEmbedded(scaler, model, featureNames,
                      outPath=OUTPUT_EMBEDDED_JSON)

    print("Done.")


if __name__ == "__main__":
    main()
